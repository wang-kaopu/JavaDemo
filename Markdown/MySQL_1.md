# 关系数据库概述

大量数据的管理出现问题：

- 读写文件并解析出数据需要大量代码
- 从大量数据中快速查询出指定数据需要复杂的逻辑

数据库作为一种专门管理数据的软件出现

应用程序不需要自己管理数据，而是通过数据库软件提供的接口来读写数据

数据本身如何存储到文件也交给数据库软件解决

## 数据模型

层次模型：上下级，类似树状

网状模型：每个数据节点和其他很多节点联系起来

关系模型：把数据看成一个二维表格，任何数据都可以通过行号+列号来唯一确定，看起来就是一张Excel表；获得了最广泛的应用。

## 数据类型

对于一个关系表，除了定义每一列的名称外，还需要定义每一列的数据类型

关系数据库支持的标准数据类型包括数值、字符串、时间等



## SQL

Structured Query Language

SQL是结构化查询语言的缩写，用来访问和操作数据库系统

### 操作数据库的能力

DDL: Data Definition Language——定义数据（创建表、删除表、修改表结构），由数据库管理员执行

DML: Data Manipulation Language——添加、删除、更新数据，是应用程序对数据库的日常操作

DQL: Data Query Language——查询数据

### 语法特点

SQL语言关键字不区分大小写

但针对不同的数据库，对于表名和列名，有的数据库区分大小写，有的数据库不区分大小写



# 关系模型

关系模型本质上就是若干个存储数据的二维表

表的每一行称为记录(Record)，记录的是一个逻辑意义上的数据

表的每一列称为字段(Column)，同一个表的每一行记录都拥有相同的若干字段

字段定义了数据类型，以及是否允许为NULL（NULL表示字段数据不存在，而非表示其值为0或为空串）。通常字段应该避免允许为NULL，简化查询条件，加快查询速度，利于程序读取数据后无需判断是否为NULL。

关系数据库的表和表之间需要建立“一对多”、“多对一”、“一对一”的关系，来组织和存储数据

在关系数据库中，关系是通过主键和外键来维护的

## 主键

#### 什么是主键

对于关系表，一个很重要的约束是任意两条记录不能重复

不能重复不是指两条记录不完全相同，而是指能够通过某个字段唯一区分出不同的记录，这个字段被称为*主键*。

#### 对主键的要求

记录一旦插入到表中，主键最好不要再修改，因为主键是用来唯一定位记录的，修改了主键，会造成一系列的影响。

#### 选取主键

不使用任何业务相关的字段作为主键，一般把这个字段命名为`id`

常见的可作为`id`字段的类型有：

1. ***自增整数类型***：数据库会在插入数据时自动为每一条记录分配一个自增整数，这样我们就完全不用担心主键重复，也不用自己预先生成主键；
2. ***全局唯一GUID类型***：使用一种全局唯一的字符串作为主键，类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。

对于大部分应用来说，通常自增类型的主键就能满足需求。我们在`students`表中定义的主键也是`BIGINT NOT NULL AUTO_INCREMENT`类型。

 如果使用INT自增类型，那么当一张表的记录数超过2147483647（约21亿）时，会达到上限而出错。使用BIGINT自增类型则可以最多约922亿亿条记录。

#### 联合主键

关系数据库实际上还允许通过多个字段唯一标识记录，即两个或更多的字段都设置为主键，这种主键被称为联合主键

对于联合主键，允许一列有重复，只要不是所有主键列都重复即可

没有必要的情况下，我们尽量不使用联合主键，因为它给关系表带来了复杂度的上升



## 外键

在`students`表中，通过`class_id`的字段，可以把数据与另一张表关联起来，这种列称为`外键`。

外键并不是通过列名实现的，而是通过定义外键约束实现的：

```
ALTER TABLE students
ADD CONSTRAINT fk_class_id
FOREIGN KEY (class_id)
REFERENCES classes (id);
```

其中，外键约束的名称`fk_class_id`可以任意，`FOREIGN KEY (class_id)`指定了`class_id`作为外键，`REFERENCES classes (id)`指定了这个外键将关联到`classes`表的`id`列（即`classes`表的主键）。

通过定义外键约束，关系数据库可以保证无法插入无效的数据。即如果`classes`表不存在`id=99`的记录，`students`表就无法插入`class_id=99`的记录。

由于外键约束会降低数据库的性能，大部分互联网应用程序为了追求速度，并不设置外键约束，而是仅靠应用程序自身来保证逻辑的正确性。这种情况下，`class_id`仅仅是一个普通的列，只是它起到了外键的作用而已。

要删除一个外键约束，也是通过`ALTER TABLE`实现的：

```
ALTER TABLE students
DROP FOREIGN KEY fk_class_id;
```

注意：删除外键约束并没有删除外键这一列。删除列是通过`DROP COLUMN ...`实现的。



## 索引

索引是关系数据库中对某一列或多个列的值进行预排序的数据结构。通过使用索引，可以让数据库系统不必扫描整个表，而是直接定位到符合条件的记录，这样就大大加快了查询速度。

如果要经常根据`score`列进行查询，就可以对`score`列创建索引：

```
ALTER TABLE students
ADD INDEX idx_score (score);
```

使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`，使用列`score`的索引。索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：

```
ALTER TABLE students
ADD INDEX idx_name_score (name, score);
```

索引的效率取决于索引列的值是否散列，即该列的值如果越互不相同，那么索引效率越高。反过来，如果记录的列存在大量相同的值，例如`gender`列，大约一半的记录值是`M`，另一半是`F`，因此，对该列创建索引就没有意义。

可以对一张表创建多个索引。索引的优点是提高了查询效率，缺点是在插入、更新和删除记录时，需要同时修改索引，因此，索引越多，插入、更新和删除记录的速度就越慢。

对于主键，关系数据库会自动对其创建主键索引。使用主键索引的效率是最高的，因为主键会保证绝对唯一。

### 唯一索引

在设计关系数据表的时候，看上去唯一的列，例如身份证号、邮箱地址等，因为他们具有业务含义，因此不宜作为主键。

但是，这些列根据业务要求，又具有唯一性约束：即不能出现两条记录存储了同一个身份证号。这个时候，就可以给该列添加一个唯一索引。例如，我们假设`students`表的`name`不能重复：

```
ALTER TABLE students
ADD UNIQUE INDEX uni_name (name);
```

通过`UNIQUE`关键字我们就添加了一个唯一索引。

也可以只对某一列添加一个唯一约束而不创建唯一索引：

```
ALTER TABLE students
ADD CONSTRAINT uni_name UNIQUE (name);
```

这种情况下，`name`列没有索引，但仍然具有唯一性保证。

无论是否创建索引，对于用户和应用程序来说，使用关系数据库不会有任何区别。这里的意思是说，当我们在数据库中查询时，如果有相应的索引可用，数据库系统就会自动使用索引来提高查询效率，如果没有索引，查询也能正常执行，只是速度会变慢。因此，索引可以在使用数据库的过程中逐步优化。